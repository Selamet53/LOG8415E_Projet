import boto3
import os
from scripts import mysql, gatekeeper

class EC2Manager:
    def __init__(self):
        self.ec2 = boto3.resource('ec2', region_name='us-east-1')
        self.ec2_client = boto3.client('ec2', region_name='us-east-1')
        self.vpc_id = ''
        self.instances_micro = []
        self.gatekeeper = []
        self.trustedHost = []
        self.proxy = []
        self.key_pair_name = 'my_key_pair'
        self.userData_Gatekeeper = gatekeeper
        self.userData_TrustedHost = ''
        self.userData_Proxy = ''
        self.userData_SQL = mysql

    def create_key_pair(self):
        try:
            key_pair = self.ec2_client.create_key_pair(KeyName=self.key_pair_name)
            private_key = key_pair['KeyMaterial']
            key_pair_file = f"{self.key_pair_name}.pem"

            with open(key_pair_file, "w") as file:
                file.write(private_key)

            print(f"Key pair '{self.key_pair_name}' created and saved as '{key_pair_file}'")
        except self.ec2_client.exceptions.ClientError as e:
            if 'InvalidKeyPair.Duplicate' in str(e):
                print(f"Key pair '{self.key_pair_name}' already exists.")
            else:
                raise
    
    def delete_key_pair(self):
        try:
            self.ec2_client.delete_key_pair(KeyName=self.key_pair_name)
            print(f"Deleted key pair '{self.key_pair_name}' from AWS.")

            key_pair_file = f"{self.key_pair_name}.pem"
            if os.path.exists(key_pair_file):
                os.remove(key_pair_file)
                print(f"Deleted local key pair file '{key_pair_file}'.")
        except self.ec2_client.exceptions.ClientError as e:
            print(f"Error deleting key pair: {e}")

    # Gatekeeper Setup
    def create_security_group_gatekeeper(self):
        response = self.ec2.create_security_group(
            GroupName='gatekeeper-security-group',
            Description='Security group for Gatekeeper instance',
            VpcId=self.vpc_id
        )
        security_group_id = response.group_id

        self.ec2_client.authorize_security_group_ingress(
            GroupId=security_group_id,
            IpPermissions=[
                { # Port open to any ip outside
                    'IpProtocol': 'tcp',
                    'FromPort': 8000,
                    'ToPort': 8000,
                    'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
                },
                { # Reminder : For ssh -> remove?
                    'IpProtocol': 'tcp',
                    'FromPort': 22,
                    'ToPort': 22,
                    'IpRanges': [{'CidrIp': "0.0.0.0/0"}]
                }
            ]
        )

        print(f"Created Security Group: {security_group_id} for the gatekeeper")
        return security_group_id
    
    def launch_gatekeeper(self):
        security_group_id = self.create_security_group_gatekeeper()

        self.gatekeeper = self.ec2.create_instances(
            ImageId='ami-0e86e20dae9224db8',
            MinCount=1,
            MaxCount=1,
            InstanceType='t2.large',
            SecurityGroupIds= [security_group_id],
            KeyName='my_key_pair',
            UserData = self.userData_Gatekeeper
        )

    
    # Trusted host Setup
    def create_security_group_trusted_host(self):
        response = self.ec2.create_security_group(
            GroupName='trusted-host-security-group',
            Description='Security group for Trusted host instance',
            VpcId=self.vpc_id
        )
        security_group_id = response.group_id

        self.ec2_client.authorize_security_group_ingress(
            GroupId=security_group_id,
            IpPermissions=[
                # { # Port open to any ip outside
                #     'IpProtocol': 'tcp',
                #     'FromPort': 8000,
                #     'ToPort': 8000,
                #     'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
                # },
                { # Reminder : For ssh -> remove?
                    'IpProtocol': 'tcp',
                    'FromPort': 22,
                    'ToPort': 22,
                    'IpRanges': [{'CidrIp': "0.0.0.0/0"}]
                }
            ]
        )

        print(f"Created Security Group: {security_group_id} for the trusted host")
        return security_group_id
    
    def launch_trusted_host(self):
        security_group_id = self.create_security_group_trusted_host()

        self.trustedHost = self.ec2.create_instances(
            ImageId='ami-0e86e20dae9224db8',
            MinCount=1,
            MaxCount=1,
            InstanceType='t2.large',
            SecurityGroupIds= [security_group_id],
            KeyName='my_key_pair',
            UserData = self.userData_TrustedHost
        )


    # Proxy Setup
    def create_security_group_proxy(self):
        response = self.ec2.create_security_group(
            GroupName='proxy-security-group',
            Description='Security group for proxy instance',
            VpcId=self.vpc_id
        )
        security_group_id = response.group_id

        self.ec2_client.authorize_security_group_ingress(
            GroupId=security_group_id,
            IpPermissions=[
                # { # Port open to any ip outside
                #     'IpProtocol': 'tcp',
                #     'FromPort': 8000,
                #     'ToPort': 8000,
                #     'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
                # },
                { # Reminder : For ssh -> remove?
                    'IpProtocol': 'tcp',
                    'FromPort': 22,
                    'ToPort': 22,
                    'IpRanges': [{'CidrIp': "0.0.0.0/0"}]
                }
            ]
        )

        print(f"Created Security Group: {security_group_id} for the proxy")
        return security_group_id
    
    def launch_proxy(self):
        security_group_id = self.create_security_group_proxy()

        self.proxy = self.ec2.create_instances(
            ImageId='ami-0e86e20dae9224db8',
            MinCount=1,
            MaxCount=1,
            InstanceType='t2.large',
            SecurityGroupIds= [security_group_id],
            KeyName='my_key_pair',
            UserData = self.userData_Proxy
        )

        
    # Cluster Setup
    def create_security_group_cluster(self):
        response = self.ec2.create_security_group(
            GroupName='my-security-group',
            Description='Security group for ALB and EC2 instances',
            VpcId=self.vpc_id
        )
        security_group_id = response.group_id

        self.ec2_client.authorize_security_group_ingress(
            GroupId=security_group_id,
            IpPermissions=[
                # {
                #     'IpProtocol': 'tcp',
                #     'FromPort': 8000,
                #     'ToPort': 8000,
                #     'IpRanges': [{'CidrIp': '0.0.0.0/0'}]
                # },
                { # Reminder : For ssh -> remove?
                    'IpProtocol': 'tcp',
                    'FromPort': 22,
                    'ToPort': 22,
                    'IpRanges': [{'CidrIp': "0.0.0.0/0"}]
                }
            ]
        )

        print(f"Created Security Group: {security_group_id} for the cluster nodes")
        return security_group_id
    
    def launch_cluster(self):
        security_group_id = self.create_security_group_cluster()

        self.instances_micro = self.ec2.create_instances(
            ImageId='ami-0e86e20dae9224db8',
            MinCount=3,
            MaxCount=3,
            InstanceType='t3.micro',
            SecurityGroupIds= [security_group_id],
            KeyName='my_key_pair',
            UserData = self.userData_SQL
        )
    
    # Launching the instances
    def launch_instances(self):
        self.launch_gatekeeper()
        self.launch_trusted_host()
        self.launch_proxy()
        self.launch_cluster()

        instances = self.gatekeeper + self.trustedHost + self.proxy + self.instances_micro
        for instance in instances:
            instance.wait_until_running()

    # Terminating all resources from AWS
    def cleanup_resources(self):
        input(f"\nReady to terminate EC2 instances. Press Enter to proceed...")

        instances = self.ec2_client.describe_instances()
        instance_ids = [
            instance['InstanceId']
            for reservation in instances['Reservations']
            for instance in reservation['Instances']
            if instance['State']['Name'] != 'terminated'
        ]

        if instance_ids:
            self.ec2_client.terminate_instances(InstanceIds=instance_ids)
            self.ec2_client.get_waiter('instance_terminated').wait(InstanceIds=instance_ids)
            print(f"Terminated instances: {instance_ids}")

        response = self.ec2_client.describe_security_groups(
            Filters=[{'Name': 'group-name', 
                      'Values': ['my-security-group', 'gatekeeper-security-group', 'trusted-host-security-group', 'proxy-security-group']}]
        )

        if response['SecurityGroups']:
            for i in range(4):
                security_group = response['SecurityGroups'][i]
                security_group_id = security_group['GroupId']

                try:
                    self.ec2_client.delete_security_group(GroupId=security_group_id)
                    print(f"Deleted Security Group")
                except self.ec2_client.exceptions.ClientError as e:
                    print(f"Error deleting security group: {e}")
                
        self.delete_key_pair()

def main():
    ec2_manager = EC2Manager()
    ec2_manager.create_key_pair()
    ec2_manager.vpc_id = ec2_manager.ec2_client.describe_vpcs()["Vpcs"][0]['VpcId']
    ec2_manager.launch_instances()
    ec2_manager.cleanup_resources()

if __name__ == "__main__":
    main()
